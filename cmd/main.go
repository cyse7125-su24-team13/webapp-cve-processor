package main

import (
	"archive/zip"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"mycveprocessor/pkg/cve"
	"mycveprocessor/pkg/db"
	"mycveprocessor/pkg/kafkapkg"
	"net/http"
	"os"
	"path/filepath"
	"strings"
)

const zipURL = "https://github.com/CVEProject/cvelistV5/archive/refs/heads/main.zip"

func main() {
	// Connect to database
	database, err := db.Connect()
	if err != nil {
		log.Fatalf("Failed to connect to database: %v", err)
	}
	defer database.Close()

	// Create database schema
	err = db.CreateSchema(database)
	if err != nil {
		log.Fatalf("Failed to create schema: %v", err)
	}

	// Initialize Kafka producer
	producer, err := kafkapkg.InitializeKafkaProducer()
	if err != nil {
		log.Fatalf("Failed to initialize Kafka producer: %v", err)
	}
	defer producer.Close()

	// Download and unzip the CVE files
	// err = downloadAndUnzip(zipURL, "cve-data")
	// if err != nil {
	// 	log.Fatalf("Failed to download and unzip CVE files: %v", err)
	// }

	rootDir := "cve-data"
	err = filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		// Exclude delta.json and deltaLog.json files
		if info.Name() == "delta.json" || info.Name() == "deltaLog.json" {
			log.Printf("Skipping file: %s", path)
			return nil
		}
		if !info.IsDir() && filepath.Ext(path) == ".json" {
			cveRecord, err := cve.ParseCVEFile(path)
			if err != nil {
				log.Printf("Failed to parse CVE file %s: %v", path, err)
				return nil // Continue processing other files
			}
			log.Printf("Parsed CVE record: %s", cveRecord.CVEID)

			// Convert CVE record to JSON
			jsonPayload, err := json.Marshal(cveRecord)
			if err != nil {
				log.Printf("Failed to encode CVE record to JSON: %v", err)
				return nil // Continue processing other files
			}

			// Send JSON payload to Kafka
			err = kafkapkg.SendJSONToKafka(producer, jsonPayload, "cve")
			if err != nil {
				log.Fatalf("Error sending JSON to Kafka: %v", err)
			}
		}
		return nil
	})
	if err != nil {
		log.Fatalf("Error walking the path %q: %v\n", rootDir, err)
	}
}

// Remaining functions (downloadAndUnzip, unzipFile) remain unchanged
// downloadAndUnzip downloads a ZIP file from the given URL and extracts its contents to the specified directory
func downloadAndUnzip(url, dest string) error {
	// Create the destination directory
	if err := os.MkdirAll(dest, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %v", dest, err)
	}

	// Download the ZIP file
	resp, err := http.Get(url)
	if err != nil {
		return fmt.Errorf("failed to download file: %v", err)
	}
	defer resp.Body.Close()

	// Check if the downloaded file is a ZIP file
	contentType := resp.Header.Get("Content-Type")
	if !strings.Contains(contentType, "zip") {
		return fmt.Errorf("downloaded file is not a zip file, content type: %s", contentType)
	}

	// Save the downloaded file to a local file
	tmpFile, err := os.CreateTemp("", "cve_data_*.zip")
	if err != nil {
		return fmt.Errorf("failed to create temporary file: %v", err)
	}
	defer os.Remove(tmpFile.Name())

	_, err = io.Copy(tmpFile, resp.Body)
	if err != nil {
		return fmt.Errorf("failed to write to temporary file: %v", err)
	}

	// Close the temporary file
	if err := tmpFile.Close(); err != nil {
		return fmt.Errorf("failed to close temporary file: %v", err)
	}

	// Unzip the main ZIP file
	err = unzipFile(tmpFile.Name(), dest)
	if err != nil {
		return fmt.Errorf("failed to unzip file: %v", err)
	}

	return nil
}

// unzipFile unzips a ZIP file to the specified destination directory
func unzipFile(zipPath, dest string) error {
	r, err := zip.OpenReader(zipPath)
	if err != nil {
		return fmt.Errorf("failed to open zip file: %v", err)
	}
	defer r.Close()

	for _, f := range r.File {
		fpath := filepath.Join(dest, f.Name)
		if !strings.HasPrefix(fpath, filepath.Clean(dest)+string(os.PathSeparator)) {
			return fmt.Errorf("illegal file path: %s", fpath)
		}

		if f.FileInfo().IsDir() {
			os.MkdirAll(fpath, os.ModePerm)
			continue
		}

		if err := os.MkdirAll(filepath.Dir(fpath), os.ModePerm); err != nil {
			return err
		}

		outFile, err := os.OpenFile(fpath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, f.Mode())
		if err != nil {
			return err
		}

		rc, err := f.Open()
		if err != nil {
			return err
		}

		_, err = io.Copy(outFile, rc)

		// Close the file without defer to close before next iteration
		outFile.Close()
		rc.Close()

		if err != nil {
			return err
		}
	}

	return nil
}
